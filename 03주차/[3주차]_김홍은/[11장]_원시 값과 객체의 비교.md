### 🔗 목차

1. [원시 값](#1-원시-값)
2. [객체](#2-객체)

---

# 11장. 원시 값과 객체의 비교

| 원시 타입의 값                                                                                      | 객체 타입의 값                                                                                         |
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| 변경 불가능한 값                                                                                    | 변경 가능한 값                                                                                         |
| 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.                          | 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.                                |
| 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. ⇒ **값에 의한 전달** | 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. ⇒ **참조에 의한 전달** |

<br/>

## 1) 원시 값

### (1) 변경 불가능한 값

- **원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값(immutable value) 이다.**
- 한 번 생성된 **원시 값**은 **읽기 전용(read only**) 값으로서 변경할 수 없다.
- **변수 ≠ 값**
  - 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름
  - 값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
  - 즉, **"값을 변경할 수 없다"는 것은 변수가 아니라 값에 대한 진술이다.**
- "원시 값은 변경 불가능하다"라는 말은 원시 값 자체를 변경할 수 없다는 것이지, 변수 값을 변경할 수 없다는 것이 아니다.
  - 즉, 변수는 언제든지 재할당을 통해 변수 값을 변경(엄밀히 말하면 교체)할 수 있다.
- 변수의 상대 개념인 **상수**는 **재할당이 금지된 변수**를 말한다.
  - 상수도 값을 저장하기 위한 메모리 공간이 필요하기 때문에 변수라고 할 수 있다.
  - 단, 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있지만, 상수는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다.
  - 따라서, 상수와 변경 불가능한 값을 동일시 여기면 안된다.
    <br/>

#### ◈ 원시 값을 할당한 변수에 새로운 원시 값을 재할당하는 경우

- 메모리 공간에 저장되어 있는 재할당 이전의 **원시 값을 변경하는 것이 아니다.**
  1. 새로운 메모리 공간을 확보한 후,
  2. 재할당한 원시 값을 저장하고,
  3. 변수는 새롭게 재할당한 원시 값을 가리킨다.
     ⇒ 이 때, 변수가 참조하던 메모리 공간의 주소가 바뀐다.
- 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다.
  ![Untitled (4)](https://github.com/hongii/Book-Shop/assets/93701887/35237859-f2b4-4d43-aa67-8d0362a69bc0)
- 즉, 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없고 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. ⇒ 이러한 값의 특성을 **불변성(immutability)** 이라 한다.
- 불변성을 값는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

> **🧐 만약 원시 값이 변경 가능한 값이라면?**
>
> 변수에 새로운 원시 값을 재할당 했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경한다. 따라서, 변수가 참조하던 메모리 공간의 주소는 바뀌지 않는다.
>
> ![Untitled (5)](https://github.com/hongii/Book-Shop/assets/93701887/1081abcf-9d32-4c98-b6f3-c4ae4d8d69a4)

<br/>

### (2) 문자열과 불변성

- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능하다.
- **문자열**은 **유사 배열 객체**이면서 **이터러블**(34장 참고)이므로 배열과 유사하게 각 문자에 접근이 가능하다.
- 원시 값은 어떤 일이 있어도 불변한다.
  - 따라서, 예기치 못한 변경으로부터 자유로워 데이터의 신뢰성을 보장한다.

```jsx
var str = "string";

// 문자열은 유사 배열 객체로 인덱스를 사용해 각 문자에 접근 가능
// 문자열은 원시 값이므로 변경 불가 -> 이때 에러가 발생하지 않는다.
// 한번 생성된 문자열은 읽기 전용 값으로서 변경이 불가능함
str[0] = "5";

console.log(str); // string
```

> **유사 배열 객체란?**
>
> 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 갖는 객체를 말한다.
> 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있고 `length` 프로퍼티를 가지기 때문에 유사 배열 객체이며 for문으로 순회를 할 수도 있다.

<br/>

### (3) 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면, 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다. ⇒ 이를 **값에 의한 전달**이라고 한다.

```jsx
var score = 80;

// copy 변수에는 score 변수의 값인 80이 복사되어 할당됨
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

// score 변수와 copy 변수의 값 80은 서로 다른 메모리 공간에 저장된 별개의 값이다.
// score 변수의 값을 변경해도 copy 변수의 값에 영향을 주지 않는다.
score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

![Untitled (6)](https://github.com/hongii/Book-Shop/assets/93701887/0ca44167-e5f6-40c4-a9ff-bc9d598dd97d)

- **"값에 의한 전달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**
- 위의 예제에서, **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되기 때문에 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**

<br/><br/>

## 2) 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다.
- 따라서, 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

> **자바스크립트 객체의 관리 방식**
>
> 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블(hash table)이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블 보다 나은 방법으로 객체를 구현한다.
> 참고로 해시 테이블은 연관 배열, map, dictionary, lookup table이라고 부르기도 한다.
>
> ![Untitled (7)](https://github.com/hongii/Book-Shop/assets/93701887/12cb6e64-38c1-43bf-8814-7dd8bc80ecc0)

<br/>

### (1) 변경 가능한 값

- **객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.**
- 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이를 **참조 값(reference value)** 이라고 한다.
  - 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.
- 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.

```jsx
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: "Lee",
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
// person 변수는 객체 {name: "Lee"}를 가리키고(참조하고) 있다.
console.log(person); // {name: "Lee"}
```

![Untitled (8)](https://github.com/hongii/Book-Shop/assets/93701887/099b9969-81ea-4b55-9f40-63f39179f0f6)

- 원시 값을 할당한 변수의 경우, "변수는 O값을 갖는다" 또는 "변수의 값은 O다"라고 표현한다.
- 객체를 할당한 변수의 경우 "변수는 객체를 참조하고 있다" 또는 "변수는 객체를 가리키고 있다"라고 표현한다.
  <br/>

#### ◈ 원시 값을 할당한 변수의 값을 변경하는 경우 VS 객체를 할당한 변수의 값을 변경하는 경우

- **원시 값을 할당한 변수** : 원시 값은 변경 불가능한 값이므로, 원시 값을 갖는 변수의 값을 변경하려면 재할당하는 방법 뿐이다. 재할당을 통해 메모리에 원시 값을 새롭게 생성해야 한다.
- **객체를 할당한 변수** : 객체는 변경 가능한 값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉, 재할당 없이 프로퍼티를 동적으로 추가, 프로퍼티 값 갱신, 프로퍼티 삭제가 가능하다.

  ```jsx
  var person = {
    name: "Lee",
  };

  // 프로퍼티 값 갱신
  person.name = "Kim";

  // 프로퍼티 동적 생성
  person.address = "Seoul";

  console.log(person); // {name: "Kim", address: "Seoul"}
  ```

  ![Untitled (9)](https://github.com/hongii/Book-Shop/assets/93701887/5381d1f3-34f2-42c2-b7f3-558f9b341290)

<br/>

#### ◈ 객체를 생성하고 관리하는 방식은 매우 복잡하고 비용이 많이 든다.

- 객체는 그 크기가 매우 클 수 있고, 원시 값처럼 크기가 일정하지 않으며, 프로퍼티 값이 객체일 수도 있어서 복사(deep copy)해서 생성하는 비용이 많이 든다.
  - 즉, 메모리의 효율적 소비가 어렵고 성능이 나빠진다.
- 메모리를 효율적으로 사용하고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
- 하지만 객체는 이러한 구조적 단점에 따른 부작용이 있는데, 이는 **여러 개의 식별자가 하나의 객체를 공유할 수 있다**는 것이다.

> **얕은 복사와 깊은 복사**
>
> 객체를 프로퍼티 값으로 갖는 객체의 경우, **얕은 복사(shallow copy)는 한 단계까지만 복사하는 것**을 말하고 **깊은 복사(deep copy)는 객체에 중첩되어 있는 객체까지 모두 복사하는 것**을 말한다.
>
> ```jsx
> const obj = { x: { y: 1 } };
>
> // 얕은 복사
> const shallowCopy = { ...obj }; // 스프레드 문법으로 얕은 복사(35장 참고)
> console.log(shallowCopy === obj); // false
> console.log(shallowCopy.x === obj.x); // true
>
> // lodash의 cloneDeep을 사용한 깊은 복사
> // npm install lodash를 통해 lodash를 설치 후, Node.js 환경에서 사용
> const _ = require("lodash");
> const deepCopy = _.cloneDeep(obj);
> console.log(deepCopy === obj); // false
> console.log(deepCopy.x === obj.x); // false
> ```
>
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 즉, 원본과 복사본은 참조 값이 다른 별개의 객체다.
> 하지만, 얕은 복사는 객체에 중첩되어 있는 객체의 경우에는 참조 값을 복사하고, 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전히 복사본을 만든다는 차이가있다.

<br/>

### (2) 참조에 의한 전달

- 객체를 가리키는 변수(원본)를 다른 변수(사본)에 할당하면 원본의 **참조 값이 복사되어 전달되는데, 이를** **참조에 의한 전달이라고 한다.**

```jsx
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

![Untitled (10)](https://github.com/hongii/Book-Shop/assets/93701887/a4c250ba-ef8d-44aa-8570-48d8e5d2e8ac)

- 위의 예제에서, 원본 `person`을 사본 `copy`에 할당하면 원본 `person`의 참조 값을 복사해서 `copy`에 저장한다.
  - 이때 원본 `person`과 사본 `copy`의 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다.
  - 즉, 원본 `person`과 사본 `copy`는 모두 동일한 객체를 가리키며, 이는 **두 개의 식별자가 하나의 객체를 공유한다는 것을 의미**한다.
  - 따라서, 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
- 결국에는 **“값에 의한 전달"** 과 **"참조에 의한 전달"** 은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.**
  - 다만 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이가 있다.

⇒ 따라서 **자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만 존재한다고 말할 수 있다.**
